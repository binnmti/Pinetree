@using Pinetree.Client.Services
@using System.Threading.Tasks
@inject IJSRuntime JSRuntime

<div id="emoji-picker-backdrop" class="emoji-picker-backdrop">
    <div id="emoji-picker-modal" class="emoji-picker-modal">
        <div class="emoji-picker-header">
            <h4 class="emoji-picker-title">
                Select an Emoji
            </h4>
            <button @onclick="() => OnEmojiSelected(string.Empty)" 
                    class="emoji-picker-close-btn">&times;</button>
        </div>
        <div class="emoji-picker-content">
            <div class="emoji-picker-search-container">
                <input type="text" placeholder="Search emojis... (try: smile, heart, food, etc.)" id="emoji-search" 
                       class="emoji-picker-search"
                       @oninput="HandleSearch" 
                       @onfocus="e => HandleSearchFocus(true)"
                       @onblur="e => HandleSearchFocus(false)" />
            </div>
            <div id="emoji-categories" class="emoji-picker-categories">
                @if (!string.IsNullOrEmpty(SearchQuery) && !HasSearchResults())
                {
                    <div id="emoji-no-results" class="emoji-no-results">
                        No emojis found for "@SearchQuery"
                    </div>
                }
                @foreach (var category in GetCategoriesToDisplay())
                {
                    <div class="emoji-category @(ShouldDisplayCategory(category.Key) ? "" : "hidden")" data-category="@category.Key.ToLower()">
                        @{
                            var visibleEmojis = category.Value.Where(emoji => ShouldDisplayEmoji(emoji)).ToList();
                            if (visibleEmojis.Count > 0 || string.IsNullOrEmpty(SearchQuery))
                            {
                                <h5 class="emoji-category-title">@category.Key</h5>
                                <div class="emoji-grid">                                    @foreach (var emoji in category.Value)
                                    {
                                        <button @onclick="() => OnEmojiSelected(emoji)" 
                                                class="emoji-picker-button @(ShouldDisplayEmoji(emoji) ? "" : "hidden")"
                                                title="@emoji" data-emoji="@emoji">@emoji</button>
                                    }
                                </div>
                            }
                        }
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter]
    public Dictionary<string, string[]> EmojiCategories { get; set; } = new();

    [Parameter]
    public EventCallback<string> OnSelect { get; set; }    private string SearchQuery { get; set; } = string.Empty;
    private Dictionary<string, bool> _searchResults = new();
    private Dictionary<string, bool> _categoryVisibility = new();
    private CancellationTokenSource _debounceTokenSource = new();
    private Dictionary<string, string[]> _keywordsCache = new();
    
    protected override void OnInitialized()
    {
        // Focus search input when component is rendered
        _ = Task.Run(async () =>
        {
            await Task.Delay(100);
            try
            {
                await JSRuntime.InvokeVoidAsync("document.getElementById('emoji-search').focus");
                
                // Prefetch emoji keywords for common emojis to improve search responsiveness
                _ = PrefetchEmojiKeywords();
            }
            catch
            {
                // Element might not be available yet
            }
        });
    }
      private async Task PrefetchEmojiKeywords()
    {
        try
        {
            // Get a sample of common emojis to prefetch
            var commonEmojis = EmojiCategories
                .SelectMany(c => c.Value)
                .Take(50)  // Limit to a reasonable number
                .ToList();
                
            // Prefetch in batches to avoid blocking the UI
            const int batchSize = 10;
            for (int i = 0; i < commonEmojis.Count; i += batchSize)
            {
                var batch = commonEmojis.Skip(i).Take(batchSize);
                foreach (var emoji in batch)
                {
                    if (!_keywordsCache.ContainsKey(emoji))
                    {
                        try
                        {
                            var keywords = await JSRuntime.InvokeAsync<string[]>("getEmojiKeywords", emoji);
                            _keywordsCache[emoji] = keywords;
                        }
                        catch
                        {
                            // Fallback if JS function call fails
                            _keywordsCache[emoji] = new[] { emoji };
                        }
                    }
                }
                // Small delay between batches to keep UI responsive
                await Task.Delay(10);
            }
        }
        catch
        {
            // Ignore prefetch errors
        }
    }private async Task HandleSearch(ChangeEventArgs e)
    {
        string query = e.Value?.ToString() ?? string.Empty;
        
        // Don't update if the query hasn't changed
        if (query == SearchQuery)
            return;
        
        SearchQuery = query;
        
        // Implement debounce to avoid excessive searches while typing
        try
        {
            _debounceTokenSource.Cancel();
            _debounceTokenSource = new CancellationTokenSource();
            var token = _debounceTokenSource.Token;
            
            // Wait a short delay before processing search to avoid excessive updates
            await Task.Delay(200, token);
            
            // Clear visibility cache when search query changes
            _categoryVisibility.Clear();
            
            // Only clear search results for the new search term
            if (string.IsNullOrWhiteSpace(SearchQuery))
            {
                _searchResults.Clear();
            }
            else 
            {
                // Update search results for all visible emojis at once
                await UpdateSearchResults();
            }
            
            await InvokeAsync(StateHasChanged);
        }
        catch (TaskCanceledException)
        {
            // Ignore cancellation - this happens when typing quickly
        }
    }
    
    private async Task UpdateSearchResults()
    {
        if (string.IsNullOrWhiteSpace(SearchQuery))
            return;
            
        var searchTerm = SearchQuery.ToLowerInvariant().Trim();
        var allEmojis = EmojiCategories.SelectMany(c => c.Value).ToList();
        
        // Process emojis in batches to maintain responsiveness
        foreach (var emoji in allEmojis)
        {
            string[] keywords;
            if (!_keywordsCache.TryGetValue(emoji, out keywords))
            {
                try 
                {
                    keywords = await JSRuntime.InvokeAsync<string[]>("getEmojiKeywords", emoji);
                    _keywordsCache[emoji] = keywords;
                }
                catch
                {
                    // Fallback if JS function call fails
                    keywords = new[] { emoji };
                }
            }
            
            bool matches = keywords.Any(k => k.ToLowerInvariant().Contains(searchTerm));
            _searchResults[emoji] = matches;
        }
    }
    
    private void HandleSearchFocus(bool isFocused)
    {
        if (isFocused)
        {
            _ = JSRuntime.InvokeVoidAsync("document.getElementById('emoji-search').classList.add", "focused");
        }
        else
        {
            _ = JSRuntime.InvokeVoidAsync("document.getElementById('emoji-search').classList.remove", "focused");
        }
    }

    private async Task OnEmojiSelected(string emoji)
    {
        await OnSelect.InvokeAsync(emoji);
    }

    private IEnumerable<KeyValuePair<string, string[]>> GetCategoriesToDisplay()
    {
        if (string.IsNullOrEmpty(SearchQuery))
        {
            return EmojiCategories;
        }
        
        return EmojiCategories.Where(c => ShouldDisplayCategory(c.Key));
    }

    private bool ShouldDisplayCategory(string categoryName)
    {
        if (string.IsNullOrEmpty(SearchQuery))
        {
            return true;
        }

        // Check cache first
        if (_categoryVisibility.TryGetValue(categoryName, out bool isVisible))
        {
            return isVisible;
        }

        if (EmojiCategories.TryGetValue(categoryName, out var emojis))
        {
            // Check if any emoji in this category matches the search
            bool hasMatch = emojis.Any(emoji => ShouldDisplayEmoji(emoji));
            _categoryVisibility[categoryName] = hasMatch;
            return hasMatch;
        }

        return false;
    }
      private bool ShouldDisplayEmoji(string emoji)
    {
        if (string.IsNullOrEmpty(SearchQuery))
        {
            return true;
        }

        // Check cache first
        if (_searchResults.TryGetValue(emoji, out bool isVisible))
        {
            return isVisible;
        }

        // If we don't have the result yet, check if we have keywords cached
        if (_keywordsCache.TryGetValue(emoji, out var keywords))
        {
            var searchTerm = SearchQuery.ToLowerInvariant().Trim();
            bool matches = keywords.Any(k => k.ToLowerInvariant().Contains(searchTerm));
            _searchResults[emoji] = matches;
            return matches;
        }

        // We don't have keywords yet, trigger fetch but return true initially
        _ = FetchKeywordsForEmoji(emoji);
        return true;
    }
    
    private async Task FetchKeywordsForEmoji(string emoji)
    {
        try
        {
            if (!_keywordsCache.ContainsKey(emoji))
            {
                var keywords = await JSRuntime.InvokeAsync<string[]>("getEmojiKeywords", emoji);
                _keywordsCache[emoji] = keywords;
            }
            
            var searchTerm = SearchQuery.ToLowerInvariant().Trim();
            bool matches = _keywordsCache[emoji].Any(k => k.ToLowerInvariant().Contains(searchTerm));
            
            if (_searchResults.TryGetValue(emoji, out bool currentValue) && currentValue != matches)
            {
                _searchResults[emoji] = matches;
                await InvokeAsync(StateHasChanged);
            }
            else if (!_searchResults.ContainsKey(emoji))
            {
                _searchResults[emoji] = matches;
                await InvokeAsync(StateHasChanged);
            }
        }
        catch
        {
            // Fallback if JS function call fails
            if (!_searchResults.ContainsKey(emoji))
            {
                _searchResults[emoji] = string.IsNullOrEmpty(SearchQuery) || 
                                      emoji.Contains(SearchQuery);
                await InvokeAsync(StateHasChanged);
            }
        }
    }
    
    private bool HasSearchResults()
    {
        if (string.IsNullOrEmpty(SearchQuery))
        {
            return true;
        }
        
        return EmojiCategories.Any(c => 
            c.Value.Any(emoji => 
                _searchResults.TryGetValue(emoji, out bool isVisible) && isVisible));
    }
}
