@using Pinetree.Client.Services
@using System.Threading.Tasks
@inject IJSRuntime JSRuntime

<div id="emoji-picker-backdrop" class="emoji-picker-backdrop">
    <div id="emoji-picker-modal" class="emoji-picker-modal">
        <div class="emoji-picker-header">
            <h4 class="emoji-picker-title">
                Select an Emoji
            </h4>
            <button @onclick="() => OnEmojiSelected(string.Empty)" 
                    class="emoji-picker-close-btn">&times;</button>
        </div>
        <div class="emoji-picker-content">
            <div class="emoji-picker-search-container">
                <input type="text" placeholder="Search emojis... (try: smile, heart, food, etc.)" id="emoji-search" 
                       class="emoji-picker-search"
                       @oninput="HandleSearch" 
                       @onfocus="e => HandleSearchFocus(true)"
                       @onblur="e => HandleSearchFocus(false)" />
            </div>
            <div id="emoji-categories" class="emoji-picker-categories">
                @if (!string.IsNullOrEmpty(SearchQuery) && !HasSearchResults())
                {
                    <div id="emoji-no-results" class="emoji-no-results">
                        No emojis found for "@SearchQuery"
                    </div>
                }
                @foreach (var category in GetCategoriesToDisplay())
                {
                    <div class="emoji-category @(ShouldDisplayCategory(category.Key) ? "" : "hidden")" data-category="@category.Key.ToLower()">
                        @{
                            var visibleEmojis = category.Value.Where(emoji => ShouldDisplayEmoji(emoji)).ToList();
                            if (visibleEmojis.Count > 0 || string.IsNullOrEmpty(SearchQuery))
                            {
                                <h5 class="emoji-category-title">@category.Key</h5>
                                <div class="emoji-grid">                                    @foreach (var emoji in category.Value)
                                    {
                                        <button @onclick="() => OnEmojiSelected(emoji)" 
                                                class="emoji-picker-button @(ShouldDisplayEmoji(emoji) ? "" : "hidden")"
                                                title="@emoji" data-emoji="@emoji">@emoji</button>
                                    }
                                </div>
                            }
                        }
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter]
    public Dictionary<string, string[]> EmojiCategories { get; set; } = new();

    [Parameter]
    public EventCallback<string> OnSelect { get; set; }

    private string SearchQuery { get; set; } = string.Empty;
    private Dictionary<string, bool> _searchResults = new();
    private Dictionary<string, bool> _categoryVisibility = new();
    protected override void OnInitialized()
    {
        // Focus search input when component is rendered
        _ = Task.Run(async () =>
        {
            await Task.Delay(100);
            try
            {
                await JSRuntime.InvokeVoidAsync("eval", "document.getElementById('emoji-search')?.focus()");
                
                // Prefetch emoji keywords for common emojis to improve search responsiveness
                _ = PrefetchEmojiKeywords();
            }
            catch
            {
                // Element might not be available yet
            }
        });
    }
    
    private async Task PrefetchEmojiKeywords()
    {
        try
        {
            // Get a sample of common emojis to prefetch
            var commonEmojis = EmojiCategories
                .SelectMany(c => c.Value)
                .Take(50)  // Limit to a reasonable number
                .ToList();
                
            foreach (var emoji in commonEmojis)
            {
                if (!_searchResults.ContainsKey(emoji))
                {
                    await FetchEmojiKeywords(emoji);
                }
            }
        }
        catch
        {
            // Ignore prefetch errors
        }
    }

    private async Task HandleSearch(ChangeEventArgs e)
    {
        SearchQuery = e.Value?.ToString() ?? string.Empty;
        
        // Clear cache when search query changes
        _searchResults.Clear();
        _categoryVisibility.Clear();
        
        await InvokeAsync(StateHasChanged);
    }
    
    private void HandleSearchFocus(bool isFocused)
    {
        if (isFocused)
        {
            _ = JSRuntime.InvokeVoidAsync("eval", "document.getElementById('emoji-search').classList.add('focused')");
        }
        else
        {
            _ = JSRuntime.InvokeVoidAsync("eval", "document.getElementById('emoji-search').classList.remove('focused')");
        }
    }

    private async Task OnEmojiSelected(string emoji)
    {
        await OnSelect.InvokeAsync(emoji);
    }

    private IEnumerable<KeyValuePair<string, string[]>> GetCategoriesToDisplay()
    {
        if (string.IsNullOrEmpty(SearchQuery))
        {
            return EmojiCategories;
        }
        
        return EmojiCategories.Where(c => ShouldDisplayCategory(c.Key));
    }

    private bool ShouldDisplayCategory(string categoryName)
    {
        if (string.IsNullOrEmpty(SearchQuery))
        {
            return true;
        }

        // Check cache first
        if (_categoryVisibility.TryGetValue(categoryName, out bool isVisible))
        {
            return isVisible;
        }

        if (EmojiCategories.TryGetValue(categoryName, out var emojis))
        {
            // Check if any emoji in this category matches the search
            bool hasMatch = emojis.Any(emoji => ShouldDisplayEmoji(emoji));
            _categoryVisibility[categoryName] = hasMatch;
            return hasMatch;
        }

        return false;
    }
    
    private bool ShouldDisplayEmoji(string emoji)
    {
        if (string.IsNullOrEmpty(SearchQuery))
        {
            return true;
        }

        // Check cache first
        if (_searchResults.TryGetValue(emoji, out bool isVisible))
        {
            return isVisible;
        }

        // Use JavaScript's getEmojiKeywords function
        _ = FetchEmojiKeywords(emoji);

        // Initially show all emojis until we have keywords
        return true;
    }
    
    private async Task FetchEmojiKeywords(string emoji)
    {
        try
        {
            var keywords = await JSRuntime.InvokeAsync<string[]>("getEmojiKeywords", emoji);
            var searchTerm = SearchQuery.ToLowerInvariant().Trim();
            bool matches = string.IsNullOrEmpty(searchTerm) || 
                           keywords.Any(k => k.ToLowerInvariant().Contains(searchTerm));
            
            _searchResults[emoji] = matches;
            await InvokeAsync(StateHasChanged);
        }
        catch
        {
            // Fallback if JS function call fails
            _searchResults[emoji] = string.IsNullOrEmpty(SearchQuery) || 
                                   emoji.Contains(SearchQuery);
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private bool HasSearchResults()
    {
        if (string.IsNullOrEmpty(SearchQuery))
        {
            return true;
        }
        
        return EmojiCategories.Any(c => 
            c.Value.Any(emoji => 
                _searchResults.TryGetValue(emoji, out bool isVisible) && isVisible));
    }
}
