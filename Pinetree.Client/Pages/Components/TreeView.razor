@using Pinetree.Client.ViewModels
@using Pinetree.Client.Services
@using Microsoft.JSInterop

@implements IAsyncDisposable

@if (IsRoot && !IsPublicView)
{
    <div class="toolbar p-2 bg-light border-bottom d-flex justify-content-start align-items-center mb-2">
        <div class="btn-toolbar" role="toolbar" aria-label="Tree actions toolbar">
            <div class="btn-group me-2" role="group" aria-label="Navigation">
                <button class="btn btn-sm btn-outline-dark" title="Move Left (Out of current level)"
                        @onclick="MoveCurrentItemLeft" disabled="@(!CanMoveCurrentItemLeft())">
                    <i class="bi bi-arrow-left"></i>
                </button>
                <button class="btn btn-sm btn-outline-dark" title="Move Right (Into as child)"
                        @onclick="MoveCurrentItemRight" disabled="@(!CanMoveCurrentItemRight())">
                    <i class="bi bi-arrow-right"></i>
                </button>
                <button class="btn btn-sm btn-outline-dark" title="Move Up"
                        @onclick="MoveCurrentItemUp" disabled="@(!CanMoveCurrentItemUp())">
                    <i class="bi bi-arrow-up"></i>
                </button>
                <button class="btn btn-sm btn-outline-dark" title="Move Down"
                        @onclick="MoveCurrentItemDown" disabled="@(!CanMoveCurrentItemDown())">
                    <i class="bi bi-arrow-down"></i>
                </button>
            </div>
        </div>
    </div>
}

@if (Pinetree != null)
{
    <ul class="list-unstyled" style="padding-left: 0.75rem;" @ref="treeViewContainer">
        <li style="" data-guid="@Pinetree.Guid">
            <div class="d-flex justify-content-between list-group-item-action">
                <div class="d-flex align-items-center">
                    @if (Pinetree.Children.Count != 0)
                    {
                        if (Pinetree.IsExpanded)
                        {
                            <i class="bi bi-caret-down" @onclick="OnClickExpanded" style="cursor:pointer"></i>
                        }
                        else
                        {
                            <i class="bi bi-caret-right" @onclick="OnClickExpanded" style="cursor:pointer"></i>
                        }
                    }
                    else
                    {
                        <span style="display:inline-block; width:1em;"></span>
                    }
                    <i class="bi bi-file-earmark-text"></i>
                </div>
                @if (Pinetree.IsCurrent)
                {
                    <div class="title px-1 flex-grow-1 border" @onclick="ActivePinetree" style="font-weight: bold; background-color:aliceblue">@Pinetree.Title</div>
                }
                else
                {
                    <div class="title px-1 flex-grow-1" @onclick="ActivePinetree">@Pinetree.Title</div>
                }
                @if (!IsPublicView)
                {
                    <div class="btn-group btn-group-sm">
                        <button class="btn btn-outline-dark btn-sm" title="Add Child Item" @onclick="AddChild">
                            <i class="bi bi-file-earmark-plus"></i>
                        </button>
                        <button class="btn btn-outline-dark btn-sm" title="Delete Item" @onclick="() => DeleteCurrentItem(Pinetree)" disabled="@(!CanDeleteItem(Pinetree))">
                            <i class="bi bi-trash2"></i>
                        </button>
                    </div>
                }
            </div>
            @if (Pinetree.IsExpanded)
            {
                @foreach (var tree in Pinetree.Children)
                {
                    <TreeView Pinetree="@(tree)" Guid="@(Guid)" IsTry=@IsTry IsProfessional=@IsProfessional
                              OnChildEvent="OnChildEvent" RootNode="RootNode ?? Pinetree" IsRoot="false" IsPublicView="IsPublicView" />
                }
            }
        </li>
    </ul>
}

@code {
    [Parameter]
    public Guid Guid { get; set; }

    [Parameter]
    public required PinetreeView Pinetree { get; set; }

    [Parameter]
    public bool IsTry { get; set; }

    [Parameter]
    public EventCallback<Guid> OnChildEvent { get; set; }

    [Parameter]
    public bool IsProfessional { get; set; }

    [Parameter]
    public PinetreeView? RootNode { get; set; }

    [Parameter]
    public bool IsRoot { get; set; } = true;

    [Parameter]
    public bool IsPublicView { get; set; } = false;

    [Inject]
    public required NavigationManager NavigationManager { get; set; }
    
    [Inject]
    public required HttpClient HttpClient { get; set; }
    
    [Inject]
    public required IJSRuntime JS { get; set; }
    
    private ElementReference treeViewContainer;
    private DotNetObjectReference<TreeView>? objRef;
    private IJSObjectReference? jsModule;

    protected override void OnInitialized()
    {
        if (IsRoot)
        {
            RootNode = Pinetree;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && IsRoot && !IsPublicView)
        {
            objRef = DotNetObjectReference.Create(this);
            try
            {
                jsModule = await JS.InvokeAsync<IJSObjectReference>("import", "/Pages/Components/TreeView.razor.js");
                await jsModule.InvokeVoidAsync("setupTreeViewDragDrop", treeViewContainer, objRef);
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Error initializing drag and drop: {ex.Message}");
            }
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (jsModule != null)
        {
            await jsModule.DisposeAsync();
        }

        objRef?.Dispose();
    }

    [JSInvokable]
    public async Task HandleItemDrop(string sourceId, string targetId, string position, string? targetParentId = null)
    {
        try
        {
            if (Guid.TryParse(sourceId, out var sourceGuid) && Guid.TryParse(targetId, out var targetGuid))
            {
                var rootNode = RootNode ?? Pinetree;
                var sourceItem = GetNodeById(rootNode, sourceGuid);
                var targetItem = GetNodeById(rootNode, targetGuid);

                if (sourceItem != null && targetItem != null)
                {
                    // Prevent dropping on itself or its descendants
                    if (IsDescendantOf(targetItem, sourceItem))
                    {
                        await JS.AlertAsync("Cannot move an item into its own descendant");
                        return;
                    }

                    bool success = false;

                    // Handle different drop positions using the PinetreeMover extension methods
                    switch (position)
                    {
                        case "into":
                            // Move as a child of the target (like right arrow button)
                            success = sourceItem.MoveItemAsChildOf(targetItem);
                            // Ensure the parent is expanded so the user can see the moved item
                            if (success) targetItem.IsExpanded = true;
                            break;
                        case "before":
                            // Properly handle drag and drop between children of the same parent
                            success = sourceItem.MoveItemBefore(targetItem);
                            break;
                        case "after":
                            // Properly handle drag and drop between children of the same parent
                            success = sourceItem.MoveItemAfter(targetItem);
                            break;
                    }

                    if (success)
                    {
                        await OnChildEvent.InvokeAsync(sourceItem.Guid);
                        StateHasChanged();
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error handling item drop: {ex.Message}");
        }
    }

    private bool IsDescendantOf(PinetreeView descendant, PinetreeView ancestor)
    {
        var parent = descendant.Parent;
        while (parent != null)
        {
            if (parent == ancestor)
                return true;
            parent = parent.Parent;
        }
        return false;
    }
    
    private bool MoveNodeBefore(PinetreeView sourceNode, PinetreeView targetNode)
    {
        if (targetNode.Parent == null)
            return false;

        var targetParent = targetNode.Parent;
        var targetIndex = targetParent.Children.IndexOf(targetNode);

        if (targetIndex < 0)
            return false;

        // If source and target have different parents, we need to ensure the hierarchy is maintained
        bool differentParents = sourceNode.Parent != targetParent;

        // Remove from old parent
        if (sourceNode.Parent != null)
        {
            // If source is already in the same parent and before the target, adjust the target index
            if (!differentParents && sourceNode.Parent.Children.IndexOf(sourceNode) < targetIndex)
            {
                targetIndex--;
            }
            
            sourceNode.Parent.Children.Remove(sourceNode);
        }

        // Add to the target's parent at the correct position
        sourceNode.Parent = targetParent;
        targetParent.Children.Insert(targetIndex, sourceNode);

        return true;
    }

    private bool MoveNodeAfter(PinetreeView sourceNode, PinetreeView targetNode)
    {
        if (targetNode.Parent == null)
            return false;

        var targetParent = targetNode.Parent;
        var targetIndex = targetParent.Children.IndexOf(targetNode);

        if (targetIndex < 0)
            return false;

        // If source and target have different parents, ensure hierarchy is maintained
        bool differentParents = sourceNode.Parent != targetParent;

        // Remove from old parent
        if (sourceNode.Parent != null)
        {
            // If source is already in the same parent and before the target, no need to adjust index
            // If source is after the target, adjust the index
            if (!differentParents && sourceNode.Parent.Children.IndexOf(sourceNode) <= targetIndex)
            {
                targetIndex--;
            }
            
            sourceNode.Parent.Children.Remove(sourceNode);
        }

        // Add to the target's parent at the correct position
        sourceNode.Parent = targetParent;
        targetParent.Children.Insert(targetIndex + 1, sourceNode);

        return true;
    }

    private bool MoveNodeInto(PinetreeView sourceNode, PinetreeView targetNode)
    {
        // Cannot move if it would create a cycle
        if (sourceNode == targetNode)
            return false;

        // Remove from old parent
        if (sourceNode.Parent != null)
        {
            sourceNode.Parent.Children.Remove(sourceNode);
        }

        // Add as child of target
        sourceNode.Parent = targetNode;
        targetNode.Children.Add(sourceNode);

        return true;
    }

    private PinetreeView? GetNodeById(PinetreeView node, Guid id)
    {
        if (node.Guid == id)
            return node;

        foreach (var child in node.Children)
        {
            var result = GetNodeById(child, id);
            if (result != null)
                return result;
        }

        return null;
    }

    private void OnClickExpanded()
    {
        Pinetree.IsExpanded = !Pinetree.IsExpanded;
        StateHasChanged();
    }

    private async Task ActivePinetree()
    {
        await OnChildEvent.InvokeAsync(Pinetree.Guid);
        StateHasChanged();
    }

    private async Task AddChild()
    {
        var newChildId = await MarkdownUtil.AddChildAsync(Pinetree, "Untitled", "", JS, HttpClient, IsTry, IsProfessional);
        await OnChildEvent.InvokeAsync(newChildId);
        StateHasChanged();
    }

    private bool CanDeleteItem(PinetreeView item)
    {
        return item != null && item.Parent != null;
    }

    private async Task DeleteCurrentItem(PinetreeView item)
    {
        if (item == null || item.Parent == null)
            return;

        if (!item.Parent.Children.Contains(item))
        {
            await JS.AlertAsync("Invalid item state. Please refresh the page.");
            return;
        }

        var confirmed = await JS.ConfirmAsync($"Are you sure you want to delete '{item.Title}'?");
        if (!confirmed)
            return;

        var idToNavigate = item.DeleteIncludeChild();

        if (idToNavigate != Guid.Empty)
        {
            await OnChildEvent.InvokeAsync(idToNavigate);
        }

        StateHasChanged();
    }

    private bool CanMoveCurrentItemUp()
    {
        var rootNode = RootNode ?? Pinetree;
        var currentItem = GetCurrentItem(rootNode);
        if (currentItem == null)
            return false;

        return currentItem.Parent != null &&
               currentItem.Parent.Children.IndexOf(currentItem) > 0;
    }

    private bool CanMoveCurrentItemDown()
    {
        var rootNode = RootNode ?? Pinetree;
        var currentItem = GetCurrentItem(rootNode);
        if (currentItem == null || currentItem.Parent == null)
            return false;

        var parent = currentItem.Parent;
        var index = parent.Children.IndexOf(currentItem);
        return index >= 0 && index < parent.Children.Count - 1;
    }

    private bool CanMoveCurrentItemRight()
    {
        var rootNode = RootNode ?? Pinetree;
        var currentItem = GetCurrentItem(rootNode);
        if (currentItem == null || currentItem.Parent == null)
            return false;

        var parent = currentItem.Parent;
        var index = parent.Children.IndexOf(currentItem);

        return index > 0 && parent.Children[index - 1] != currentItem.Parent;
    }

    private bool CanMoveCurrentItemLeft()
    {
        var rootNode = RootNode ?? Pinetree;
        var currentItem = GetCurrentItem(rootNode);

        return currentItem != null && currentItem.Parent != null && currentItem.Parent.Parent != null;
    }

    private async Task MoveCurrentItemUp()
    {
        var rootNode = RootNode ?? Pinetree;
        var currentItem = GetCurrentItem(rootNode);
        if (currentItem == null)
            return;

        if (currentItem.MoveItemUp())
        {
            await OnChildEvent.InvokeAsync(currentItem.Guid);
            StateHasChanged();
        }
    }

    private async Task MoveCurrentItemDown()
    {
        var rootNode = RootNode ?? Pinetree;
        var currentItem = GetCurrentItem(rootNode);
        if (currentItem == null)
            return;

        if (currentItem.MoveItemDown())
        {
            await OnChildEvent.InvokeAsync(currentItem.Guid);
            StateHasChanged();
        }
    }

    private async Task MoveCurrentItemRight()
    {
        var rootNode = RootNode ?? Pinetree;
        var currentItem = GetCurrentItem(rootNode);
        if (currentItem == null)
            return;

        var originalParent = currentItem.Parent;
        if (originalParent == null)
            return;

        if (currentItem.MoveItemRight())
        {
            await OnChildEvent.InvokeAsync(currentItem.Guid);
            StateHasChanged();
        }
    }

    private async Task MoveCurrentItemLeft()
    {
        var rootNode = RootNode ?? Pinetree;
        var currentItem = GetCurrentItem(rootNode);
        if (currentItem == null)
            return;

        var originalParent = currentItem.Parent;
        if (originalParent == null || originalParent.Parent == null)
            return;

        if (currentItem.MoveItemLeft())
        {
            await OnChildEvent.InvokeAsync(currentItem.Guid);
            StateHasChanged();
        }
    }

    private PinetreeView? GetCurrentItem(PinetreeView node)
    {
        if (node == null) return null;

        if (node.IsCurrent)
            return node;

        foreach (var child in node.Children)
        {
            var result = GetCurrentItem(child);
            if (result != null)
                return result;
        }

        return null;
    }
}
